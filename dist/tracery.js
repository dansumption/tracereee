/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/tracery/tracery.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/tracery/tracery.js":
/*!*******************************!*\
  !*** ./js/tracery/tracery.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author Kate\n */\n\ntracery = function() {\n\tvar rng = Math.random;\n\n\tvar setRng = function setRng(newRng) {\n\t\trng = newRng;\n\t};\n\n\tvar TraceryNode = function(parent, childIndex, settings) {\n\t\tthis.errors = [];\n\n\t\t// No input? Add an error, but continue anyways\n\t\tif (settings.raw === undefined) {\n\t\t\tthis.errors.push(\"Empty input for node\");\n\t\t\tsettings.raw = \"\";\n\t\t}\n\n\t\t// If the root node of an expansion, it will have the grammar passed as the 'parent'\n\t\t//  set the grammar from the 'parent', and set all other values for a root node\n\t\tif ( parent instanceof tracery.Grammar) {\n\t\t\tthis.grammar = parent;\n\t\t\tthis.parent = null;\n\t\t\tthis.depth = 0;\n\t\t\tthis.childIndex = 0;\n\t\t} else {\n\t\t\tthis.grammar = parent.grammar;\n\t\t\tthis.parent = parent;\n\t\t\tthis.depth = parent.depth + 1;\n\t\t\tthis.childIndex = childIndex;\n\t\t}\n\n\t\tthis.raw = settings.raw;\n\t\tthis.type = settings.type;\n\t\tthis.isExpanded = false;\n\n\t\tif (!this.grammar) {\n\t\t\tconsole.warn(\"No grammar specified for this node\", this);\n\t\t}\n\n\t};\n\n\tTraceryNode.prototype.toString = function() {\n\t\treturn \"Node('\" + this.raw + \"' \" + this.type + \" d:\" + this.depth + \")\";\n\t};\n\n\t// Expand the node (with the given child rule)\n\t//  Make children if the node has any\n\tTraceryNode.prototype.expandChildren = function(childRule, preventRecursion) {\n\t\tthis.children = [];\n\t\tthis.finishedText = \"\";\n\n\t\t// Set the rule for making children,\n\t\t// and expand it into section\n\t\tthis.childRule = childRule;\n\t\tif (this.childRule !== undefined) {\n\t\t\tvar sections = tracery.parse(childRule);\n\n\t\t\t// Add errors to this\n\t\t\tif (sections.errors.length > 0) {\n\t\t\t\tthis.errors = this.errors.concat(sections.errors);\n\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < sections.length; i++) {\n\t\t\t\tthis.children[i] = new TraceryNode(this, i, sections[i]);\n\t\t\t\tif (!preventRecursion)\n\t\t\t\t\tthis.children[i].expand(preventRecursion);\n\n\t\t\t\t// Add in the finished text\n\t\t\t\tthis.finishedText += this.children[i].finishedText;\n\t\t\t}\n\t\t} else {\n\t\t\t// In normal operation, this shouldn't ever happen\n\t\t\tthis.errors.push(\"No child rule provided, can't expand children\");\n\t\t\tconsole.warn(\"No child rule provided, can't expand children\");\n\t\t}\n\t};\n\n\t// Expand this rule (possibly creating children)\n\tTraceryNode.prototype.expand = function(preventRecursion) {\n\n\t\tif (!this.isExpanded) {\n\t\t\tthis.isExpanded = true;\n\n\t\t\tthis.expansionErrors = [];\n\n\t\t\t// Types of nodes\n\t\t\t// -1: raw, needs parsing\n\t\t\t//  0: Plaintext\n\t\t\t//  1: Tag (\"#symbol.mod.mod2.mod3#\" or \"#[pushTarget:pushRule]symbol.mod\")\n\t\t\t//  2: Action (\"[pushTarget:pushRule], [pushTarget:POP]\", more in the future)\n\n\t\t\tswitch(this.type) {\n\t\t\t// Raw rule\n\t\t\tcase -1:\n\n\t\t\t\tthis.expandChildren(this.raw, preventRecursion);\n\t\t\t\tbreak;\n\n\t\t\t// plaintext, do nothing but copy text into finsihed text\n\t\t\tcase 0:\n\t\t\t\tthis.finishedText = this.raw;\n\t\t\t\tbreak;\n\n\t\t\t// Tag\n\t\t\tcase 1:\n\t\t\t\t// Parse to find any actions, and figure out what the symbol is\n\t\t\t\tthis.preactions = [];\n\t\t\t\tthis.postactions = [];\n\n\t\t\t\tvar parsed = tracery.parseTag(this.raw);\n\n\t\t\t\t// Break into symbol actions and modifiers\n\t\t\t\tthis.symbol = parsed.symbol;\n\t\t\t\tthis.modifiers = parsed.modifiers;\n\n\t\t\t\t// Create all the preactions from the raw syntax\n\t\t\t\tfor (var i = 0; i < parsed.preactions.length; i++) {\n\t\t\t\t\tthis.preactions[i] = new NodeAction(this, parsed.preactions[i].raw);\n\t\t\t\t}\n\t\t\t\tfor (var i = 0; i < parsed.postactions.length; i++) {\n\t\t\t\t\t//   this.postactions[i] = new NodeAction(this, parsed.postactions[i].raw);\n\t\t\t\t}\n\n\t\t\t\t// Make undo actions for all preactions (pops for each push)\n\t\t\t\tfor (var i = 0; i < this.preactions.length; i++) {\n\t\t\t\t\tif (this.preactions[i].type === 0)\n\t\t\t\t\t\tthis.postactions.push(this.preactions[i].createUndo());\n\t\t\t\t}\n\n\t\t\t\t// Activate all the preactions\n\t\t\t\tfor (var i = 0; i < this.preactions.length; i++) {\n\t\t\t\t\tthis.preactions[i].activate();\n\t\t\t\t}\n\n\t\t\t\tthis.finishedText = this.raw;\n\n\t\t\t\t// Expand (passing the node, this allows tracking of recursion depth)\n\n\t\t\t\tvar selectedRule = this.grammar.selectRule(this.symbol, this, this.errors);\n\n\t\t\t\tthis.expandChildren(selectedRule, preventRecursion);\n\n\t\t\t\t// Apply modifiers\n\t\t\t\t// TODO: Update parse function to not trigger on hashtags within parenthesis within tags,\n\t\t\t\t//   so that modifier parameters can contain tags \"#story.replace(#protagonist#, #newCharacter#)#\"\n\t\t\t\tfor (var i = 0; i < this.modifiers.length; i++) {\n\t\t\t\t\tvar modName = this.modifiers[i];\n\t\t\t\t\tvar modParams = [];\n\t\t\t\t\tif (modName.indexOf(\"(\") > 0) {\n\t\t\t\t\t\tvar regExp = /\\(([^)]+)\\)/;\n\n\t\t\t\t\t\t// Todo: ignore any escaped commas.  For now, commas always split\n\t\t\t\t\t\tvar results = regExp.exec(this.modifiers[i]);\n\t\t\t\t\t\tif (!results || results.length < 2) {\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar modParams = results[1].split(\",\");\n\t\t\t\t\t\t\tmodName = this.modifiers[i].substring(0, modName.indexOf(\"(\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar mod = this.grammar.modifiers[modName];\n\n\t\t\t\t\t// Missing modifier?\n\t\t\t\t\tif (!mod) {\n\t\t\t\t\t\tthis.errors.push(\"Missing modifier \" + modName);\n\t\t\t\t\t\tthis.finishedText += \"((.\" + modName + \"))\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.finishedText = mod(this.finishedText, modParams);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Perform post-actions\n\t\t\t\tfor (var i = 0; i < this.postactions.length; i++) {\n\t\t\t\t\tthis.postactions[i].activate();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\n\t\t\t\t// Just a bare action?  Expand it!\n\t\t\t\tthis.action = new NodeAction(this, this.raw);\n\t\t\t\tthis.action.activate();\n\n\t\t\t\t// No visible text for an action\n\t\t\t\t// TODO: some visible text for if there is a failure to perform the action?\n\t\t\t\tthis.finishedText = \"\";\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else {\n\t\t\t//console.warn(\"Already expanded \" + this);\n\t\t}\n\n\t};\n\n\tTraceryNode.prototype.clearEscapeChars = function() {\n\n\t\tthis.finishedText = this.finishedText.replace(/\\\\\\\\/g, \"DOUBLEBACKSLASH\").replace(/\\\\/g, \"\").replace(/DOUBLEBACKSLASH/g, \"\\\\\");\n\t};\n\n\t// An action that occurs when a node is expanded\n\t// Types of actions:\n\t// 0 Push: [key:rule]\n\t// 1 Pop: [key:POP]\n\t// 2 function: [functionName(param0,param1)] (TODO!)\n\tfunction NodeAction(node, raw) {\n\t\t/*\n\t\t if (!node)\n\t\t console.warn(\"No node for NodeAction\");\n\t\t if (!raw)\n\t\t console.warn(\"No raw commands for NodeAction\");\n\t\t */\n\n\t\tthis.node = node;\n\n\t\tvar sections = raw.split(\":\");\n\t\tthis.target = sections[0];\n\n\t\t// No colon? A function!\n\t\tif (sections.length === 1) {\n\t\t\tthis.type = 2;\n\n\t\t}\n\n\t\t// Colon? It's either a push or a pop\n\t\telse {\n\t\t\tthis.rule = sections[1];\n\t\t\tif (this.rule === \"POP\") {\n\t\t\t\tthis.type = 1;\n\t\t\t} else {\n\t\t\t\tthis.type = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tNodeAction.prototype.createUndo = function() {\n\t\tif (this.type === 0) {\n\t\t\treturn new NodeAction(this.node, this.target + \":POP\");\n\t\t}\n\t\t// TODO Not sure how to make Undo actions for functions or POPs\n\t\treturn null;\n\t};\n\n\tNodeAction.prototype.activate = function() {\n\t\tvar grammar = this.node.grammar;\n\t\tswitch(this.type) {\n\t\tcase 0:\n\t\t\t// split into sections (the way to denote an array of rules)\n\t\t\tthis.ruleSections = this.rule.split(\",\");\n\t\t\tthis.finishedRules = [];\n\t\t\tthis.ruleNodes = [];\n\t\t\tfor (var i = 0; i < this.ruleSections.length; i++) {\n\t\t\t\tvar n = new TraceryNode(grammar, 0, {\n\t\t\t\t\ttype : -1,\n\t\t\t\t\traw : this.ruleSections[i]\n\t\t\t\t});\n\n\t\t\t\tn.expand();\n\n\t\t\t\tthis.finishedRules.push(n.finishedText);\n\t\t\t}\n\n\t\t\t// TODO: escape commas properly\n\t\t\tgrammar.pushRules(this.target, this.finishedRules, this);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgrammar.popRules(this.target);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgrammar.flatten(this.target, true);\n\t\t\tbreak;\n\t\t}\n\n\t};\n\n\tNodeAction.prototype.toText = function() {\n\t\tswitch(this.type) {\n\t\tcase 0:\n\t\t\treturn this.target + \":\" + this.rule;\n\t\tcase 1:\n\t\t\treturn this.target + \":POP\";\n\t\tcase 2:\n\t\t\treturn \"((some function))\";\n\t\tdefault:\n\t\t\treturn \"((Unknown Action))\";\n\t\t}\n\t};\n\n\t// Sets of rules\n\t// Can also contain conditional or fallback sets of rulesets)\n\tfunction RuleSet(grammar, raw) {\n\t\tthis.raw = raw;\n\t\tthis.grammar = grammar;\n\t\tthis.falloff = 1;\n\n\t\tif (Array.isArray(raw)) {\n\t\t\tthis.defaultRules = raw;\n\t\t} else if ( typeof raw === 'string' || raw instanceof String) {\n\t\t\tthis.defaultRules = [raw];\n\t\t} else if (raw === 'object') {\n\t\t\t// TODO: support for conditional and hierarchical rule sets\n\t\t}\n\n\t};\n\n\tRuleSet.prototype.selectRule = function(errors) {\n\t\t// console.log(\"Get rule\", this.raw);\n\t\t// Is there a conditional?\n\t\tif (this.conditionalRule) {\n\t\t\tvar value = this.grammar.expand(this.conditionalRule, true);\n\t\t\t// does this value match any of the conditionals?\n\t\t\tif (this.conditionalValues[value]) {\n\t\t\t\tvar v = this.conditionalValues[value].selectRule(errors);\n\t\t\t\tif (v !== null && v !== undefined)\n\t\t\t\t\treturn v;\n\t\t\t}\n\t\t\t// No returned value?\n\t\t}\n\n\t\t// Is there a ranked order?\n\t\tif (this.ranking) {\n\t\t\tfor (var i = 0; i < this.ranking.length; i++) {\n\t\t\t\tvar v = this.ranking.selectRule();\n\t\t\t\tif (v !== null && v !== undefined)\n\t\t\t\t\treturn v;\n\t\t\t}\n\n\t\t\t// Still no returned value?\n\t\t}\n\n\t\tif (this.defaultRules !== undefined) {\n\t\t\tvar index = 0;\n\t\t\t// Select from this basic array of rules\n\n\t\t\t// Get the distribution from the grammar if there is no other\n\t\t\tvar distribution = this.distribution;\n\t\t\tif (!distribution)\n\t\t\t\tdistribution = this.grammar.distribution;\n\n\t\t\tswitch(distribution) {\n\t\t\tcase \"shuffle\":\n\n\t\t\t\t// create a shuffle desk\n\t\t\t\tif (!this.shuffledDeck || this.shuffledDeck.length === 0) {\n\t\t\t\t\t// make an array\n\t\t\t\t\tthis.shuffledDeck = fyshuffle(Array.apply(null, {\n\t\t\t\t\t\tlength : this.defaultRules.length\n\t\t\t\t\t}).map(Number.call, Number), this.falloff);\n\n\t\t\t\t}\n\n\t\t\t\tindex = this.shuffledDeck.pop();\n\n\t\t\t\tbreak;\n\t\t\tcase \"weighted\":\n\t\t\t\terrors.push(\"Weighted distribution not yet implemented\");\n\t\t\t\tbreak;\n\t\t\tcase \"falloff\":\n\t\t\t\terrors.push(\"Falloff distribution not yet implemented\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\n\t\t\t\tindex = Math.floor(Math.pow(rng(), this.falloff) * this.defaultRules.length);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!this.defaultUses)\n\t\t\t\tthis.defaultUses = [];\n\t\t\tthis.defaultUses[index] = ++this.defaultUses[index] || 1;\n\t\t\treturn this.defaultRules[index];\n\t\t}\n\n\t\terrors.push(\"No default rules defined for \" + this);\n\t\treturn null;\n\n\t};\n\n\tRuleSet.prototype.clearState = function() {\n\n\t\tif (this.defaultUses) {\n\t\t\tthis.defaultUses = [];\n\t\t}\n\t};\n\n\tfunction fyshuffle(array, falloff) {\n\t\tvar currentIndex = array.length,\n\t\t    temporaryValue,\n\t\t    randomIndex;\n\n\t\t// While there remain elements to shuffle...\n\t\twhile (0 !== currentIndex) {\n\n\t\t\t// Pick a remaining element...\n\t\t\trandomIndex = Math.floor(rng() * currentIndex);\n\t\t\tcurrentIndex -= 1;\n\n\t\t\t// And swap it with the current element.\n\t\t\ttemporaryValue = array[currentIndex];\n\t\t\tarray[currentIndex] = array[randomIndex];\n\t\t\tarray[randomIndex] = temporaryValue;\n\t\t}\n\n\t\treturn array;\n\t}\n\n\tvar Symbol = function(grammar, key, rawRules) {\n\t\t// Symbols can be made with a single value, and array, or array of objects of (conditions/values)\n\t\tthis.key = key;\n\t\tthis.grammar = grammar;\n\t\tthis.rawRules = rawRules;\n\n\t\tthis.baseRules = new RuleSet(this.grammar, rawRules);\n\t\tthis.clearState();\n\n\t};\n\n\tSymbol.prototype.clearState = function() {\n\n\t\t// Clear the stack and clear all ruleset usages\n\t\tthis.stack = [this.baseRules];\n\n\t\tthis.uses = [];\n\t\tthis.baseRules.clearState();\n\t};\n\n\tSymbol.prototype.pushRules = function(rawRules) {\n\t\tvar rules = new RuleSet(this.grammar, rawRules);\n\t\tthis.stack.push(rules);\n\t};\n\n\tSymbol.prototype.popRules = function() {\n\t\tthis.stack.pop();\n\t};\n\n\tSymbol.prototype.selectRule = function(node, errors) {\n\t\tthis.uses.push({\n\t\t\tnode : node\n\t\t});\n\n\t\tif (this.stack.length === 0) {\n\t\t\terrors.push(\"The rule stack for '\" + this.key + \"' is empty, too many pops?\");\n\t\t\treturn \"((\" + this.key + \"))\";\n\t\t}\n\n\t\treturn this.stack[this.stack.length - 1].selectRule();\n\t};\n\n\tSymbol.prototype.getActiveRules = function() {\n\t\tif (this.stack.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.stack[this.stack.length - 1].selectRule();\n\t};\n\n\tSymbol.prototype.rulesToJSON = function() {\n\t\treturn JSON.stringify(this.rawRules);\n\t};\n\n\tvar Grammar = function(raw, settings) {\n\t\tthis.modifiers = {};\n\t\tthis.loadFromRawObj(raw);\n\t};\n\n\tGrammar.prototype.clearState = function() {\n\t\tvar keys = Object.keys(this.symbols);\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tthis.symbols[keys[i]].clearState();\n\t\t}\n\t};\n\n\tGrammar.prototype.addModifiers = function(mods) {\n\n\t\t// copy over the base modifiers\n\t\tfor (var key in mods) {\n\t\t\tif (mods.hasOwnProperty(key)) {\n\t\t\t\tthis.modifiers[key] = mods[key];\n\t\t\t}\n\t\t};\n\n\t};\n\n\tGrammar.prototype.loadFromRawObj = function(raw) {\n\n\t\tthis.raw = raw;\n\t\tthis.symbols = {};\n\t\tthis.subgrammars = [];\n\n\t\tif (this.raw) {\n\t\t\t// Add all rules to the grammar\n\t\t\tfor (var key in this.raw) {\n\t\t\t\tif (this.raw.hasOwnProperty(key)) {\n\t\t\t\t\tthis.symbols[key] = new Symbol(this, key, this.raw[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tGrammar.prototype.createRoot = function(rule) {\n\t\t// Create a node and subnodes\n\t\tvar root = new TraceryNode(this, 0, {\n\t\t\ttype : -1,\n\t\t\traw : rule,\n\t\t});\n\n\t\treturn root;\n\t};\n\n\tGrammar.prototype.expand = function(rule, allowEscapeChars) {\n\t\tvar root = this.createRoot(rule);\n\t\troot.expand();\n\t\tif (!allowEscapeChars)\n\t\t\troot.clearEscapeChars();\n\n\t\treturn root;\n\t};\n\n\tGrammar.prototype.flatten = function(rule, allowEscapeChars) {\n\t\tvar root = this.expand(rule, allowEscapeChars);\n\n\t\treturn root.finishedText;\n\t};\n\n\tGrammar.prototype.toJSON = function() {\n\t\tvar keys = Object.keys(this.symbols);\n\t\tvar symbolJSON = [];\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tsymbolJSON.push(' \"' + key + '\" : ' + this.symbols[key].rulesToJSON());\n\t\t}\n\t\treturn \"{\\n\" + symbolJSON.join(\",\\n\") + \"\\n}\";\n\t};\n\n\t// Create or push rules\n\tGrammar.prototype.pushRules = function(key, rawRules, sourceAction) {\n\n\t\tif (this.symbols[key] === undefined) {\n\t\t\tthis.symbols[key] = new Symbol(this, key, rawRules);\n\t\t\tif (sourceAction)\n\t\t\t\tthis.symbols[key].isDynamic = true;\n\t\t} else {\n\t\t\tthis.symbols[key].pushRules(rawRules);\n\t\t}\n\t};\n\n\tGrammar.prototype.popRules = function(key) {\n\t\tif (!this.symbols[key])\n\t\t\tthis.errors.push(\"Can't pop: no symbol for key \" + key);\n\t\tthis.symbols[key].popRules();\n\t};\n\n\tGrammar.prototype.selectRule = function(key, node, errors) {\n\t\tif (this.symbols[key]) {\n\t\t\tvar rule = this.symbols[key].selectRule(node, errors);\n\n\t\t\treturn rule;\n\t\t}\n\n\t\t// Failover to alternative subgrammars\n\t\tfor (var i = 0; i < this.subgrammars.length; i++) {\n\n\t\t\tif (this.subgrammars[i].symbols[key])\n\t\t\t\treturn this.subgrammars[i].symbols[key].selectRule();\n\t\t}\n\n\t\t// No symbol?\n\t\terrors.push(\"No symbol for '\" + key + \"'\");\n\t\treturn \"((\" + key + \"))\";\n\t};\n\n\t// Parses a plaintext rule in the tracery syntax\n\ttracery = {\n\n\t\tcreateGrammar : function(raw) {\n\t\t\treturn new Grammar(raw);\n\t\t},\n\n\t\t// Parse the contents of a tag\n\t\tparseTag : function(tagContents) {\n\n\t\t\tvar parsed = {\n\t\t\t\tsymbol : undefined,\n\t\t\t\tpreactions : [],\n\t\t\t\tpostactions : [],\n\t\t\t\tmodifiers : []\n\t\t\t};\n\t\t\tvar sections = tracery.parse(tagContents);\n\t\t\tvar symbolSection = undefined;\n\t\t\tfor (var i = 0; i < sections.length; i++) {\n\t\t\t\tif (sections[i].type === 0) {\n\t\t\t\t\tif (symbolSection === undefined) {\n\t\t\t\t\t\tsymbolSection = sections[i].raw;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow (\"multiple main sections in \" + tagContents);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tparsed.preactions.push(sections[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (symbolSection === undefined) {\n\t\t\t\t//   throw (\"no main section in \" + tagContents);\n\t\t\t} else {\n\t\t\t\tvar components = symbolSection.split(\".\");\n\t\t\t\tparsed.symbol = components[0];\n\t\t\t\tparsed.modifiers = components.slice(1);\n\t\t\t}\n\t\t\treturn parsed;\n\t\t},\n\n\t\tparse : function(rule) {\n\t\t\tvar depth = 0;\n\t\t\tvar inTag = false;\n\t\t\tvar sections = [];\n\t\t\tvar escaped = false;\n\n\t\t\tvar errors = [];\n\t\t\tvar start = 0;\n\n\t\t\tvar escapedSubstring = \"\";\n\t\t\tvar lastEscapedChar = undefined;\n\n\t\t\tif (rule === null) {\n\t\t\t\tvar sections = [];\n\t\t\t\tsections.errors = errors;\n\n\t\t\t\treturn sections;\n\t\t\t}\n\n\t\t\tfunction createSection(start, end, type) {\n\t\t\t\tif (end - start < 1) {\n\t\t\t\t\tif (type === 1)\n\t\t\t\t\t\terrors.push(start + \": empty tag\");\n\t\t\t\t\tif (type === 2)\n\t\t\t\t\t\terrors.push(start + \": empty action\");\n\n\t\t\t\t}\n\t\t\t\tvar rawSubstring;\n\t\t\t\tif (lastEscapedChar !== undefined) {\n\t\t\t\t\trawSubstring = escapedSubstring + \"\\\\\" + rule.substring(lastEscapedChar + 1, end);\n\n\t\t\t\t} else {\n\t\t\t\t\trawSubstring = rule.substring(start, end);\n\t\t\t\t}\n\t\t\t\tsections.push({\n\t\t\t\t\ttype : type,\n\t\t\t\t\traw : rawSubstring\n\t\t\t\t});\n\t\t\t\tlastEscapedChar = undefined;\n\t\t\t\tescapedSubstring = \"\";\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < rule.length; i++) {\n\n\t\t\t\tif (!escaped) {\n\t\t\t\t\tvar c = rule.charAt(i);\n\n\t\t\t\t\tswitch(c) {\n\n\t\t\t\t\t// Enter a deeper bracketed section\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tif (depth === 0 && !inTag) {\n\t\t\t\t\t\t\tif (start < i)\n\t\t\t\t\t\t\t\tcreateSection(start, i, 0);\n\t\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdepth++;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tdepth--;\n\n\t\t\t\t\t\t// End a bracketed section\n\t\t\t\t\t\tif (depth === 0 && !inTag) {\n\t\t\t\t\t\t\tcreateSection(start, i, 2);\n\t\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Hashtag\n\t\t\t\t\t//   ignore if not at depth 0, that means we are in a bracket\n\t\t\t\t\tcase '#':\n\t\t\t\t\t\tif (depth === 0) {\n\t\t\t\t\t\t\tif (inTag) {\n\t\t\t\t\t\t\t\tcreateSection(start, i, 1);\n\t\t\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (start < i)\n\t\t\t\t\t\t\t\t\tcreateSection(start, i, 0);\n\t\t\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tinTag = !inTag;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\t\tescaped = true;\n\t\t\t\t\t\tescapedSubstring = escapedSubstring + rule.substring(start, i);\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tlastEscapedChar = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tescaped = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (start < rule.length)\n\t\t\t\tcreateSection(start, rule.length, 0);\n\n\t\t\tif (inTag) {\n\t\t\t\terrors.push(\"Unclosed tag\");\n\t\t\t}\n\t\t\tif (depth > 0) {\n\t\t\t\terrors.push(\"Too many [\");\n\t\t\t}\n\t\t\tif (depth < 0) {\n\t\t\t\terrors.push(\"Too many ]\");\n\t\t\t}\n\n\t\t\t// Strip out empty plaintext sections\n\n\t\t\tsections = sections.filter(function(section) {\n\t\t\t\tif (section.type === 0 && section.raw.length === 0)\n\t\t\t\t\treturn false;\n\t\t\t\treturn true;\n\t\t\t});\n\t\t\tsections.errors = errors;\n\t\t\treturn sections;\n\t\t},\n\t};\n\n\t// Externalize\n\ttracery.TraceryNode = TraceryNode;\n\n\ttracery.Grammar = Grammar;\n\ttracery.Symbol = Symbol;\n\ttracery.RuleSet = RuleSet;\n\n\ttracery.setRng = setRng;\n\n\treturn tracery;\n}();\n\n//module.exports = tracery; \n\n//# sourceURL=webpack:///./js/tracery/tracery.js?");

/***/ })

/******/ });